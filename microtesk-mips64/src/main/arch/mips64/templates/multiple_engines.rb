#
# MicroTESK for MIPS64
#
# Copyright (c) 2016-2017 Institute for System Programming of the Russian Academy of Sciences
# All Rights Reserved
#
# Institute for System Programming of the Russian Academy of Sciences (ISP RAS)
# 25 Alexander Solzhenitsyn st., Moscow, 109004, Russia
# http://www.ispras.ru
#

require_relative 'mips64_base'

#
# Description:
#
# This test template demonstrates how to o mix constraints related to ALU, BPU and MMU
# in a single instruction sequence.
#
class MultipleEnginesTemplate < Mips64BaseTemplate

  def initialize
    super
    set_option_value 'default-test-data', false
  end

  def pre
    super

    data {
      org 0x00010000
      align 8
      # Arrays to store test data for branch instructions.
      label :branch_data_0
      dword 0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0
      label :branch_data_1
      dword 0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0,    0x0, 0x0, 0x0, 0x0
    }

    stream_preparator(:data_source => 'R', :index_source => 'R') {
      init {
        la index_source, start_label
       }

      read {
        ld data_source, 0x0, index_source
        addiu index_source, index_source, 8
      }

      write {
        sd data_source, 0x0, index_source
        addiu index_source, index_source, 8
      }
    }
  end

  def run
    # Stream  Label            Data  Addr  Size
    stream   :branch_data_0,   s0,   s2,   128
    stream   :branch_data_1,   s1,   s3,   128

    # A branch structure is as follows:
    #
    #  0: NOP
    #  1: if (BGEZ) then goto 4
    #  2: ADD (IntegerOverflow)
    #  3: goto 5
    #  4: ADD(Normal) + LW (MMU)
    #  5: if (BLTZ) then goto 0

    # Parameter 'branch_exec_limit' bounds the number of executions of a single branch:
    #   the default value is 1.
    # Parameter 'trace_count_limit' bounds the number of execution traces to be created:
    #   the default value is -1 (no limitation).
    sequence(
        :engines => {
            :combinator => 'diagonal',
            :branch => {:branch_exec_limit => 3,
                        :trace_count_limit => -1},
            :memory => {:classifier => 'event-based',
                        :page_mask => 0x0fff,
                        :align => 4,
                        :count => 5}
        }) {
      label :start
        nop
        bgez s0, :normal do
          situation('bgez-if-then', :engine => :branch, :stream => 'branch_data_0')
        end
        nop

      label :overflow
        add t0, t1, t2 do situation('IntegerOverflow') end
        j :finish do
          situation('b-goto', :engine => :branch)
        end
        nop

      label :normal
        add t0, t3, t4 do situation('normal') end
        ld a0, 0x0, s4 do situation('memory', :engine => :memory, :base => 'ld.base') end
        sd a1, 0x0, s5 do situation('memory', :engine => :memory, :base => 'sd.base') end

      label :finish
        nop
        bltz s1, :start do
          situation('bltz-if-then', :engine => :branch, :stream => 'branch_data_1')
        end
        nop
    }.run
  end

end
