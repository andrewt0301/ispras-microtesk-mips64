/*
 * MicroTESK MIPS Edition
 *
 * Copyright (c) 2017 Institute for System Programming of the Russian Academy of Sciences
 * All Rights Reserved
 *
 * Institute for System Programming of the Russian Academy of Sciences (ISP RAS)
 * 25 Alexander Solzhenitsyn st., Moscow, 109004, Russia
 * http://www.ispras.ru
 */

#ifndef MIPS_BPU_INCLUDED
#define MIPS_BPU_INCLUDED

//==================================================================================================
// Branch Instructions
//==================================================================================================

/*  Instructions:
    B +
    BAL +
    BALC +
    BC +
    BEQ +
    BEQL +
    BGEZ +
    BGEZAL +
    BLEZALC +
    BGEZALC +
    BLTZALC +
    BGTZALC +
    BEQZALC +
    BNEZALC +
    BGEZALL +
    BLEZC +
    BGEZC +
    BGEC +
    BLEC +
    BGTZC +
    BLTZC +
    BLTC +
    BGTC +
    BGEUC +
    BLEUC +
    BLTUC +
    BGTUC +
    BEQC +
    BNEC +
    BEQZC +
    BNEZC +
    BGEZL +
    BGTZ +
    BGTZL +
    BLEZ +
    BLEZL +
    BLTZ +
    BLTZAL +
    BLTZALL +
    BLTZL +
    BNE +
    BNEL +
    BOVC +
    BNVC +
    J +
    JAL +
    JALR +
    JALR.HB +
    JALX +
    JIALC +
    JIC +
    JR +
    JR.HB +
    */

/*
  B: Unconditional Branch (Assembly Idiom)

  Encoding: | 31 26   | 25 21 | 20 16 | 15   0 |
            | BEQ     | 0     | 0     | offset |
            | 000100  | 00000 | 00000 |        |
            | 6       | 5     | 5     | 16     |

  Format: B offset

  Description: branch
  B offset is the assembly idiom used to denote an unconditional branch. The actual instruction is
  interpreted by the hardware as BEQ r0, r0, offset.
  An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of
  the instruction following the branch (not the branch itself), in the branch delay slot, to form a
  PC-relative effective target address.

  Operation:
    I: target_offset <- sign_extend(offset || 02)
    I+1: PC <- PC + target_offset
  */
pseudo op b (offset: SHORT)
  init = {}
  syntax = format("b %<label>d", offset)
  image  = format("0001000000000000%16s", offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    BRANCH = 1;
    NEXTPC = CIA + (sign_extend(DWORD, offset) << 2);
  }

/*
  BAL: Branch and Link (Assembly Idiom MIPS32, MIPS32 Release 6)

  Encoding: | 31 26   | 25 21 | 20 16 | 15   0 |
            | REGIMM  | 0     | BAL   | offset |
            | 000001  | 00000 | 10001 |        |
            | 6       | 5     | 5     | 16     |

  Format: BAL offset

  Description: procedure_call
  Place the return address link in GPR 31. The return link is the address of the second instruction
  following the branch, where execution continues after a procedure call.
  An 18-bit signed offset (the 16-bit offset field shifted left 2-bits) is added to the address of
  the instruction following the branch (not the branch itself), in the branch delay slot, to form
  a PC-relative effective target address.

  Operation:
    I: target_offset <- sign_extend(offset || 02)
       GPR[31] <- PC + 8
    I+1: PC <- PC + target_offset
  */
@rev(MIPS32_R6)
op bal (offset: SHORT)
  init = {}
  syntax = format("bal %<label>d", offset)
  image  = format("0000010000010001%16s", offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    GPR[31] = CIA + 8;
    BRANCH = 1;
    NEXTPC = CIA + (sign_extend(DWORD, offset) << 2);
  }

/*
  BALC: Branch and Link, Compact (MIPS32 Release 6)

  Encoding: | 31 26  | 25   0 |
            | BALC   | offset |
            | 111010 |        |
            | 6      | 26     |

  Format: BALC offset

  Description: procedure_call (no delay slot)
  Place the return address link in GPR 31. The return link is the address of the instruction
  immediately following the branch, where execution continues after a procedure call. (Because
  compact branches have no delay slots, see below.)
  A 28-bit signed offset (the 26-bit offset field shifted left 2 bits) is added to the address of
  the instruction following the branch (not the branch itself), to form a PC-relative effective
  target address.
  Compact branches do not have delay slots. The instruction after the branch is NOT executed when
  the branch is taken.

  Operation:
    target_offset <- sign_extend( offset || 02 )
    GPR[31] <- PC+4
    PC <- PC+4 + sign_extend(target_offset)
  */
@rev(MIPS32_R6)
op balc (offset: card(26))
  init = {}
  syntax = format("balc %<label>d", offset)
  image  = format("111010%26s", offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    GPR[31] = CIA + 4;
    COMPACT_BRANCH = 1;
    NEXTPC = CIA + 4 + (sign_extend(DWORD, offset) << 2);
  }

/*
  BC: Branch, Compact (MIPS32 Release 6)

  Encoding: | 31 26  | 25   0 |
            | BC     | offset |
            | 110010 |        |
            | 6      | 26     |

  Format: BC offset

  Description: PC <- PC+4 + sign_extend( offset << 2)
  A 28-bit signed offset (the 26-bit offset field shifted left 2 bits) is added to the address of
  the instruction following the branch (not the branch itself), to form a PC-relative effective
  target address.
  Compact branches have no delay slot: the instruction after the branch is NOT executed when the
  branch is taken.

  Operation:
    target_offset <- sign_extend( offset || 02 )
    PC <- ( PC+4 + sign_extend(target_offset) )
  */
@rev(MIPS32_R6)
op bc (offset: card(26))
  init = {}
  syntax = format("bc %<label>d", offset)
  image  = format("110010%26s", offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    COMPACT_BRANCH = 1;
    NEXTPC = CIA + 4 + (sign_extend(DWORD, offset) << 2);
  }

/*
  BEQ: Branch on Equal (MIPS32)

  Encoding: | 31 26   | 25 21 | 20 16 | 15   0 |
            | BEQ     | rs    | rt    | offset |
            | 000100  |       |       |        |
            | 6       | 5     | 5     | 16     |

  Format: BEQ rs, rt, offset

  Description: if GPR[rs] = GPR[rt] then branch
  An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of
  the instruction following the branch (not the branch itself), in the branch delay slot, to form
  a PC-relative effective target address. If the contents of GPR rs and GPR rt are equal, branch to
  the effective target address after the instruction in the delay slot is executed.

  Operation:
    I:
    target_offset <- sign_extend(offset || 02)
    condition <- (GPR[rs] = GPR[rt])
    I+1:
    if condition then
      PC <- PC + target_offset
    endif
  */
@rev(MIPS32_R1)
op beq (rs: R, rt: R, offset: SHORT)
  init = {}
  syntax = format("beq %s, %s, %<label>d", rs.syntax, rt.syntax, offset)
  image  = format("000100%5s%5s%16s", rs.image, rt.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    if rs == rt then
      BRANCH = 1;
      NEXTPC = CIA + (sign_extend(DWORD, offset) << 2);
    endif;
  }

/*
  BEQL: Branch on Equal Likely (MIPS32, removed in Release 6)

  Encoding: | 31 26   | 25 21 | 20 16 | 15   0 |
            | BEQL    | rs    | rt    | offset |
            | 010100  |       | 00000 |        |
            | 6       | 5     | 5     | 16     |

  Format: BEQL rs, rt, offset

  Description: if GPR[rs] = GPR[rt] then branch_likely
  An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of
  the instruction following the branch (not the branch itself), in the branch delay slot, to form
  a PC-relative effective target address.
  If the contents of GPR rs and GPR rt are equal, branch to the target address after the instruction
  in the delay slot is executed. If the branch is not taken, the instruction in the delay slot is
  not executed.

  Operation:
    I:
    target_offset <- sign_extend(offset || 02)
    condition <- (GPR[rs] = GPR[rt])
    I+1:
    if condition then
      PC <- PC + target_offset
    else
      NullifyCurrentInstruction()
    endif
  */
@rev(MIPS32_REM_R6)
op beql (rs: R, rt: R, offset: SHORT)
  init = {}
  syntax = format("beql %s, %s, %<label>d", rs.syntax, rt.syntax, offset)
  image  = format("010100%5s%5s%16s", rs.image, rt.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    if rs == rt then
      BRANCH = 1;
      NEXTPC = CIA + (sign_extend(DWORD, offset) << 2);
    else
      SKIPOP = 1;
    endif;
  }

/*
  BGEZ Branch on Greater Than or Equal to Zero (MIPS32)

  Encoding: | 31 26   | 25 21 | 20 16 | 15   0 |
            | REGIMM  | rs    | BGEZ  | offset |
            | 000001  |       | 00001 |        |
            | 6       | 5     | 5     | 16     |

  Format: BGEZ rs, offset MIPS32

  Description: if GPR[rs] >= 0 then branch
  An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of
  the instruction following the branch (not the branch itself), in the branch delay slot, to form
  a PC-relative effective target address.
  If the contents of GPR rs are greater than or equal to zero (sign bit is 0), branch to the
  effective target address after the instruction in the delay slot is executed.

  Operation:
    I:
    target_offset <- sign_extend(offset || 02)
    condition <- GPR[rs] >= 0GPRLEN
    I+1:
    if condition then
      PC <- PC + target_offset
    endif
  */
@rev(MIPS32_R1)
op bgez (rs: R, offset: SHORT)
  init = {}
  syntax = format("bgez %s, %<label>d", rs.syntax, offset)
  image  = format("000001%5s00001%16s", rs.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    if cast(LONG, rs) >= 0 then
      BRANCH = 1;
      NEXTPC = CIA + (sign_extend(DWORD, offset) << 2);
    endif;
  }

/*
  BGEZAL: Branch on Greater Than or Equal to Zero and Link (MIPS32, removed in Release 6)

  Encoding: | 31 26   | 25 21 | 20  16 | 15   0 |
            | REGIMM  | rs    | BGEZAL | offset |
            | 000001  |       | 10001  |        |
            | 6       | 5     | 5      | 16     |

  Format: BGEZAL rs, offset

  Description: if GPR[rs] >= 0 then procedure_call
  Place the return address link in GPR 31. The return link is the address of the second instruction
  following the branch, where execution continues after a procedure call.
  An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of
  the instruction following the branch (not the branch itself), in the branch delay slot, to form
  a PC-relative effective target address.
  If the contents of GPR rs are greater than or equal to zero (sign bit is 0), branch to the
  effective target address after the instruction in the delay slot is executed.

  Operation:
    I:
    target_offset <- sign_extend(offset || 02)
    condition <- GPR[rs] >= 0GPRLEN
    GPR[31] <- PC + 8
    I+1:
    if condition then
      PC <- PC + target_offset
    endif
  */
// TODO: This instruction has been removed in Release 6 with the exception of special case BAL
// (unconditional Branch and Link) which was an alias for BGEZAL with rs=0.
@rev(MIPS32_R1)
op bgezal (rs: R, offset: SHORT)
  init = {}
  syntax = format("bgezal %s, %<label>d", rs.syntax, offset)
  image  = format("000001%5s10001%16s", rs.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    GPR[31] = CIA + 8;

    if cast(LONG, rs) >= 0 then
      BRANCH = 1;
      NEXTPC = CIA + (sign_extend(DWORD, offset) << 2);
    endif;
  }

/*
  B{LE,GE,GT,LT,EQ,NE}ZALC: 
  Compact Zero-Compare and Branch-and-Link Instructions (MIPS32 Release 6)

  Encoding: | 31 26   | 25 21 | 20  16        | 15   0 |
  ------------------------------------------------------
            | POP06   | BLEZALC               | offset |
            | 000110  | 00000 | rt =/= 00000  |        |
  ------------------------------------------------------
            | POP06   | BGEZALC rs=rt=/=00000 | offset |
            | 000110  | rs    | rt            |        |
  ------------------------------------------------------
            | POP07   | BGTZALC               | offset |
            | 000111  | 00000 | rt =/= 00000  |        |
  ------------------------------------------------------
            | POP07   | BLTZALC rs=rt=/=00000 | offset |
            | 000111  | rs    | rt            |        |
  ------------------------------------------------------
            | POP10   | BEQZALC rs<rt         | offset |
            | 001000  | 00000 | rt =/= 00000  |        |
  ------------------------------------------------------
            | POP30   | BNEZALC rs<rt         | offset |
            | 011000  | 00000 | rt =/= 00000  |        |
  ------------------------------------------------------
            | 6       | 5     | 5             | 16     |

  Format:
    BLEZALC rt, offset
    BGEZALC rt, offset
    BGTZALC rt, offset
    BLTZALC rt, offset
    BEQZALC rt, offset
    BNEZALC rt, offset

  Description: if condition(GPR[rt]) then procedure_call branch (no delay slot)
  The condition is evaluated. If the condition is true, the branch is taken.
  Places the return address link in GPR 31. The return link is the address of the instruction
  immediately following the branch, where execution continues after a procedure call.
  The return address link is unconditionally updated.
  A 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of
  the instruction following the branch (not the branch itself), to form a PC-relative effective
  target address.

  BLEZALC: the condition is true if and only if GPR rt is less than or equal to zero.
  BGEZALC: the condition is true if and only if GPR rt is greater than or equal to zero.
  BLTZALC: the condition is true if and only if GPR rt is less than zero.
  BGTZALC: the condition is true if and only if GPR rt is greater than zero.
  BEQZALC: the condition is true if and only if GPR rt is equal to zero.
  BNEZALC: the condition is true if and only if GPR rt is not equal to zero.

  Compact branches do not have delay slots. The instruction after a compact branch is only executed
  if the branch is not taken.

  Operation:
    GPR[31] <- PC+4
    target_offset <- sign_extend( offset || 02 )
    BLTZALC: cond <- GPR[rt] < 0
    BLEZALC: cond <- GPR[rt] <= 0
    BGEZALC: cond <- GPR[rt] >= 0
    BGTZALC: cond <- GPR[rt] > 0
    BEQZALC: cond <- GPR[rt] = 0
    BNEZALC: cond <- GPR[rt] =/= 0
    if cond then
      PC <- ( PC+4+ sign_extend( target_offset ) )
    endif
  */
@rev(MIPS32_R6)
op blezalc (rt: R, offset: SHORT)
  init = {}
  syntax = format("blezalc %s, %<label>d", rt.syntax, offset)
  image  = format("00011000000%5s%16s", rt.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    GPR[31] = CIA + 4;

    if rt.i == 0 then
      undefined; // rt =/= 00000
    else
      if cast(LONG, rt) <= 0 then
        COMPACT_BRANCH = 1;
        NEXTPC = CIA + 4 + (sign_extend(DWORD, offset) << 2);
      endif;
    endif;
  }

@rev(MIPS32_R6)
op bgezalc (rt: R, offset: SHORT)
  init = {}
  syntax = format("bgezalc %s, %<label>d", rt.syntax, offset)
  image  = format("000110%5s%5s%16s", rt.image, rt.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    GPR[31] = CIA + 4;

    if rt.i == 0 then
      undefined; // rt =/= 00000
    else
      if cast(LONG, rt) >= 0 then
        COMPACT_BRANCH = 1;
        NEXTPC = CIA + 4 + (sign_extend(DWORD, offset) << 2);
      endif;
    endif;
  }

@rev(MIPS32_R6)
op bgtzalc (rt: R, offset: SHORT)
  init = {}
  syntax = format("bgtzalc %s, %<label>d", rt.syntax, offset)
  image  = format("00011100000%5s%16s", rt.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    GPR[31] = CIA + 4;

    if rt.i == 0 then
      undefined; // rt =/= 00000
    else
      if cast(LONG, rt) > 0 then
        COMPACT_BRANCH = 1;
        NEXTPC = CIA + 4 + (sign_extend(DWORD, offset) << 2);
      endif;
    endif;
  }

@rev(MIPS32_R6)
op bltzalc (rt: R, offset: SHORT)
  init = {}
  syntax = format("bltzalc %s, %<label>d", rt.syntax, offset)
  image  = format("000111%5s%5s%16s", rt.image, rt.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    GPR[31] = CIA + 4;

    if rt.i == 0 then
      undefined; // rt =/= 00000
    else
      if cast(LONG, rt) < 0 then
        COMPACT_BRANCH = 1;
        NEXTPC = CIA + 4 + (sign_extend(DWORD, offset) << 2);
      endif;
    endif;
  }

@rev(MIPS32_R6)
pseudo op beqzalc (rt: R, offset: SHORT)
  init = {}
  syntax = format("beqzalc %s, %<label>d", rt.syntax, offset)
  image  = format("00100000000%5s%16s", rt.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    GPR[31] = CIA + 4;

    if rt.i == 0 then
      undefined; // rt =/= 00000
    else
      if cast(LONG, rt) == 0 then
        COMPACT_BRANCH = 1;
        NEXTPC = CIA + 4 + (sign_extend(DWORD, offset) << 2);
      endif;
    endif;
  }

@rev(MIPS32_R6)
pseudo op bnezalc (rt: R, offset: SHORT)
  init = {}
  syntax = format("bnezalc %s, %<label>d", rt.syntax, offset)
  image  = format("01100000000%5s%16s", rt.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    GPR[31] = CIA + 4;

    if rt.i == 0 then
      undefined; // rt =/= 00000
    else
      if cast(LONG, rt) != 0 then
        COMPACT_BRANCH = 1;
        NEXTPC = CIA + 4 + (sign_extend(DWORD, offset) << 2);
      endif;
    endif;
  }

@rev(MIPS32_R6)
op bXzalc = @rev(MIPS32_R6) blezalc
          | @rev(MIPS32_R6) bgezalc
          | @rev(MIPS32_R6) bgtzalc
          | @rev(MIPS32_R6) bltzalc
          | @rev(MIPS32_R6) beqzalc
          | @rev(MIPS32_R6) bnezalc

/*
  BGEZALL: Branch on Greater Than or Equal to Zero and Link Likely (MIPS32, removed in Release 6)

  Encoding: | 31 26   | 25 21 | 20   16 | 15   0 |
            | REGIMM  | rs    | BGEZALL | offset |
            | 000001  |       | 10011   |        |
            | 6       | 5     | 5       | 16     |

  Format: BGEZALL rs, offset

  Description: if GPR[rs] >= 0 then procedure_call_likely
  Place the return address link in GPR 31. The return link is the address of the second instruction
  following the branch, where execution continues after a procedure call.
  An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of
  the instruction following the branch (not the branch itself), in the branch delay slot, to form
  a PC-relative effective target address.
  If the contents of GPR rs are greater than or equal to zero (sign bit is 0), branch to the
  effective target address after the instruction in the delay slot is executed. If the branch is not
  taken, the instruction in the delay slot is not executed.

  Operation:
    I:
    target_offset <- sign_extend(offset || 02)
    condition <- GPR[rs] >= 0GPRLEN
    GPR[31] <- PC + 8
    I+1:
    if condition then
      PC <- PC + target_offset
    else
      NullifyCurrentInstruction()
    endif
  */
@rev(MIPS32_REM_R6)
op bgezall (rs: R, offset: SHORT)
  init = {}
  syntax = format("bgezall %s, %<label>d", rs.syntax, offset)
  image  = format("000001%5s10011%16s", rs.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    GPR[31] = CIA + 8;

    if cast(LONG, rs) >= 0 then
      BRANCH = 1;
      NEXTPC = CIA + (sign_extend(DWORD, offset) << 2);
    else
      SKIPOP = 1;
    endif;
  }

/*
  B<cond>C: Compact Compare-and-Branch Instructions (MIPS32 Release 6)

  Encoding: | 31 26  | 25      21 | 20      16 | 15   0 |
  --------------------------------------------------------
            | POP26  | BLEZC                   | offset |
            | 010110 | 00000      | rt=/=00000 |        |
  --------------------------------------------------------
            | POP26  | BGEZC rs = rt           | offset |
            | 010110 | rs=/=00000 | rt=/=00000 |        |
  --------------------------------------------------------
            | POP26  | BGEC (BLEC) rs =/= rt   | offset |
            | 010110 | rs=/=00000 | rt=/=00000 |        |
  --------------------------------------------------------
            | POP27  | BGTZC                   | offset |
            | 010111 | 00000      | rt=/=00000 |        |
  --------------------------------------------------------
            | POP27  | BLTZC rs = rt           | offset |
            | 010111 | rs=/=00000 | rt=/=00000 |        |
  --------------------------------------------------------
            | POP27  | BLTC (BGTC) rs =/= rt   | offset |
            | 010111 | rs=/=00000 | rt=/=00000 |        |
  --------------------------------------------------------
            | POP06  | BGEUC (BLEUC) rs =/= rt | offset |
            | 000110 | rs=/=00000 | rt=/=00000 |        |
  --------------------------------------------------------
            | POP07  | BLTUC (BGTUC) rs =/= rt | offset |
            | 000111 | rs=/=00000 | rt=/=00000 |        |
  --------------------------------------------------------
            | POP10  | BEQC rs < rt            | offset |
            | 001000 | rs=/=00000 | rt=/=00000 |        |
  --------------------------------------------------------
            | POP30  | BNEC rs < rt            | offset |
            | 011000 | rs=/=00000 | rt=/=00000 |        |
  --------------------------------------------------------
            | 6      | 5          | 5          | 16     |

  Encoding: | 31 26  | 25      21 | 20   0 |
  -------------------------------------------
            | POP66  | BEQZC      | offset |
            | 110110 | rs=/=00000 |        |
  -------------------------------------------
            | POP76  | BNEZC      | offset |
            | 111110 | rs=/=00000 |        |
  -------------------------------------------
            | 6      | 5          | 21     |

  Format:

  Equal/Not-Equal register-register compare and branch with 16-bit offset:
    BEQC rs, rt, offset
    BNEC rs, rt, offset

  Signed register-register compare and branch with 16-bit offset:
    BLTC rs, rt, offset
    BGEC rs, rt, offset

  Unsigned register-register compare and branch with 16-bit offset:
    BLTUC rs, rt, offset
    BGEUC rs, rt, offset

  Assembly idioms with reversed operands for signed/unsigned compare-and-branch:
    BGTC rt, rs, offset
    BLEC rt, rs, offset
    BGTUC rt, rs, offset
    BLEUC rt, rs, offset

  Signed Compare register to Zero and branch with 16-bit offset:
    BLTZC rt, offset
    BLEZC rt, offset
    BGEZC rt, offset
    BGTZC rt, offset

  Equal/Not-equal Compare register to Zero and branch with 21-bit offset:
    BEQZC rs, offset
    BNEZC rs, offset

  Description:
  if condition(GPR[rs] and/or GPR[rt]) then compact branch (no delay slot) The condition is
  evaluated. If the condition is true, the branch is taken. An 18/23-bit signed offset
  (the 16/21-bit offset field shifted left 2 bits) is added to the address of the instruction
  following the branch (not the branch itself), to form a PC-relative effective target address.
  The offset is 16 bits for most compact branches, including BLTC, BLEC, BGEC, BGTC, BNEQC, BNEC,
  BLTUC, BLEUC, BGEUC, BGTC, BLTZC, BLEZC, BGEZC, BGTZC. The offset is 21 bits for BEQZC and BNEZC.
  Compact branches have no delay slot: the instruction after the branch is NOT executed if the
  branch is taken.

  The conditions are as follows:
  Equal/Not-equal register-register compare-and-branch with 16-bit offset:
    BEQC: Compact branch if GPRs are equal
    BNEC: Compact branch if GPRs are not equal
  Signed register-register compare and branch with 16-bit offset:
    BLTC: Compact branch if GPR rs is less than GPR rt
    BGEC: Compact branch if GPR rs is greater than or equal to GPR rt
  Unsigned register-register compare and branch with 16-bit offset:
    BLTUC: Compact branch if GPR rs is less than GPR rt, unsigned
    BGEUC: Compact branch if GPR rs is greater than or equal to GPR rt, unsigned
  Assembly Idioms with Operands Reversed:
    BLEC: Compact branch if GPR rt is less than or equal to GPR rs (alias for BGEC)
    BGTC: Compact branch if GPR rt is greater than GPR rs (alias for BLTC)
    BLEUC: Compact branch if GPR rt is less than or equal to GPR rt, unsigned (alias for BGEUC)
    BGTUC: Compact branch if GPR rt is greater than GPR rs, unsigned (alias for BLTUC)
  Compare register to zero and branch with 16-bit offset:
    BLTZC: Compact branch if GPR rt is less than zero
    BLEZC: Compact branch if GPR rt is less than or equal to zero
    BGEZC: Compact branch if GPR rt is greater than or equal to zero
    BGTZC: Compact branch if GPR rt is greater than zero
  Compare register to zero and branch with 21-bit offset:
    BEQZC: Compact branch if GPR rs is equal to zero
    BNEZC: Compact branch if GPR rs is not equal to zero

  Operation:
    target_offset <- sign_extend( offset || 02 )
    / Register-register compare and branch, 16 bit offset: /
    / Equal / Not-Equal /
    BEQC: cond <- GPR[rs] = GPR[rt]
    BNEC: cond <- GPR[rs] =/= GPR[rt]
    / Signed /
    BLTC: cond <- GPR[rs] < GPR[rt]
    BGEC: cond <- GPR[rs] >= GPR[rt]
    / Unsigned: /
    BLTUC: cond <- unsigned(GPR[rs]) < unsigned(GPR[rt])
    BGEUC: cond <- unsigned(GPR[rs]) >= unsigned(GPR[rt])
    / Compare register to zero, small offset: /
    BLTZC: cond <- GPR[rt] < 0
    BLEZC: cond <- GPR[rt] <= 0
    BGEZC: cond <- GPR[rt] >= 0
    BGTZC: cond <- GPR[rt] > 0
    / Compare register to zero, large offset: /
    BEQZC: cond <- GPR[rs] = 0
    BNEZC: cond <- GPR[rs] =/= 0

    if cond then
      PC <- ( PC+4+ sign_extend( offset ) )
    end if
  */
@rev(MIPS32_R6)
op blezc (rt: R, offset: SHORT)
  init = {}
  syntax = format("blezc %s, %<label>d", rt.syntax, offset)
  image  = format("01011000000%5s%16s", rt.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    if rt.i == 0 then
      undefined; // rt =/= 00000
    else
      if cast(LONG, rt) <= 0 then
        COMPACT_BRANCH = 1;
        NEXTPC = CIA + 4 + (sign_extend(DWORD, offset) << 2);
      endif;
    endif;
  }

@rev(MIPS32_R6)
op bgezc (rt: R, offset: SHORT)
  init = {}
  syntax = format("bgezc %s, %<label>d", rt.syntax, offset)
  image  = format("010110%5s%5s%16s", rt.image, rt.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    if rt.i == 0 then
      undefined; // rt (rs) =/= 00000
    else
      if cast(LONG, rt) >= 0 then
        COMPACT_BRANCH = 1;
        NEXTPC = CIA + 4 + (sign_extend(DWORD, offset) << 2);
      endif;
    endif;
  }

@rev(MIPS32_R6)
op bgtzc (rt: R, offset: SHORT)
  init = {}
  syntax = format("bgtzc %s, %<label>d", rt.syntax, offset)
  image  = format("01011100000%5s%16s", rt.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    if rt.i == 0 then
      undefined; // rt (rs) =/= 00000
    else
      if cast(LONG, rt) > 0 then
        COMPACT_BRANCH = 1;
        NEXTPC = CIA + 4 + (sign_extend(DWORD, offset) << 2);
      endif;
    endif;
  }

@rev(MIPS32_R6)
op bltzc (rt: R, offset: SHORT)
  init = {}
  syntax = format("bltzc %s, %<label>d", rt.syntax, offset)
  image  = format("010111%5s%5s%16s", rt.image, rt.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    if rt.i == 0 then
      undefined; // rt (rs) =/= 00000
    else
      if cast(LONG, rt) < 0 then
        COMPACT_BRANCH = 1;
        NEXTPC = CIA + 4 + (sign_extend(DWORD, offset) << 2);
      endif;
    endif;
  }

@rev(MIPS32_R6)
op bgec (rs: R, rt: R, offset: SHORT)
  init = {}
  syntax = format("bgec %s, %s, %<label>d", rs.syntax, rt.syntax, offset)
  image  = format("010110%5s%5s%16s", rs.image, rt.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    if (rt.i == rs.i) || (rt.i == 0) || (rs.i == 0) then
      undefined; // rs =/= rt, rt (rs) =/= 00000
    else
      if cast(LONG, rs) >= cast(LONG, rt) then
        COMPACT_BRANCH = 1;
        NEXTPC = CIA + 4 + (sign_extend(DWORD, offset) << 2);
      endif;
    endif;
  }

// Alias for BGEC
@rev(MIPS32_R6)
pseudo op blec (rs: R, rt: R, offset: SHORT)
  init = {}
  syntax = format("blec %s, %s, %<label>d", rs.syntax, rt.syntax, offset)
  image  = format("010110%5s%5s%16s", rs.image, rt.image, offset)
  action = {
    bgec(rt, rs, offset).action;
  }

@rev(MIPS32_R6)
op bltc (rs: R, rt: R, offset: SHORT)
  init = {}
  syntax = format("bltc %s, %s, %<label>d", rs.syntax, rt.syntax, offset)
  image  = format("010111%5s%5s%16s", rs.image, rt.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    if (rt.i == rs.i) || (rt.i == 0) || (rs.i == 0) then
      undefined; // rs =/= rt, rt (rs) =/= 00000
    else
      if cast(LONG, rs) < cast(LONG, rt) then
        COMPACT_BRANCH = 1;
        NEXTPC = CIA + 4 + (sign_extend(DWORD, offset) << 2);
      endif;
    endif;
  }

// Alias for BLTC
@rev(MIPS32_R6)
pseudo op bgtc (rs: R, rt: R, offset: SHORT)
  init = {}
  syntax = format("bgtc %s, %s, %<label>d", rs.syntax, rt.syntax, offset)
  image  = format("010111%5s%5s%16s", rs.image, rt.image, offset)
  action = {
    bltc(rt, rs, offset).action;
  }

@rev(MIPS32_R6)
op bgeuc (rs: R, rt: R, offset: SHORT)
  init = {}
  syntax = format("bgeuc %s, %s, %<label>d", rs.syntax, rt.syntax, offset)
  image  = format("000110%5s%5s%16s", rs.image, rt.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    if (rt.i == rs.i) || (rt.i == 0) || (rs.i == 0) then
      undefined; // rs =/= rt, rt (rs) =/= 00000
    else
      if rs >= rt then
        COMPACT_BRANCH = 1;
        NEXTPC = CIA + 4 + (sign_extend(DWORD, offset) << 2);
      endif;
    endif;
  }

// Alias for BGEUC
@rev(MIPS32_R6)
pseudo op bleuc (rs: R, rt: R, offset: SHORT)
  init = {}
  syntax = format("bleuc %s, %s, %<label>d", rs.syntax, rt.syntax, offset)
  image  = format("000110%5s%5s%16s", rs.image, rt.image, offset)
  action = {
    bgeuc(rt, rs, offset).action;
  }

@rev(MIPS32_R6)
op bltuc (rs: R, rt: R, offset: SHORT)
  init = {}
  syntax = format("bltuc %s, %s, %<label>d", rs.syntax, rt.syntax, offset)
  image  = format("000111%5s%5s%16s", rs.image, rt.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    if (rt.i == rs.i) || (rt.i == 0) || (rs.i == 0) then
      undefined; // rs =/= rt, rt (rs) =/= 00000
    else
      if rs < rt then
        COMPACT_BRANCH = 1;
        NEXTPC = CIA + 4 + (sign_extend(DWORD, offset) << 2);
      endif;
    endif;
  }

// Alias for BLTUC
@rev(MIPS32_R6)
pseudo op bgtuc (rs: R, rt: R, offset: SHORT)
  init = {}
  syntax = format("bgtuc %s, %s, %<label>d", rs.syntax, rt.syntax, offset)
  image  = format("000111%5s%5s%16s", rs.image, rt.image, offset)
  action = {
    bltuc(rt, rs, offset).action;
  }

@rev(MIPS32_R6)
op beqc (rs: R, rt: R, offset: SHORT)
  init = {}
  syntax = format("beqc %s, %s, %<label>d", rs.syntax, rt.syntax, offset)
  image  = format("001000%5s%5s%16s", rs.image, rt.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    if (rs.i < rt.i) || (rt.i == 0) || (rs.i == 0) then
      undefined; // rs < rt, rt (rs) =/= 00000
    else
      if rs == rt then
        COMPACT_BRANCH = 1;
        NEXTPC = CIA + 4 + (sign_extend(DWORD, offset) << 2);
      endif;
    endif;
  }

@rev(MIPS32_R6)
op bnec (rs: R, rt: R, offset: SHORT)
  init = {}
  syntax = format("bnec %s, %s, %<label>d", rs.syntax, rt.syntax, offset)
  image  = format("011000%5s%5s%16s", rs.image, rt.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    if (rs.i < rt.i) || (rt.i == 0) || (rs.i == 0) then
      undefined; // rs < rt, rt (rs) =/= 00000
    else
      if rs != rt then
        COMPACT_BRANCH = 1;
        NEXTPC = CIA + 4 + (sign_extend(DWORD, offset) << 2);
      endif;
    endif;
  }

op beqzc (rs: R, offset: card(21))
  init = {}
  syntax = format("beqzc %s, %<label>d", rs.syntax, offset)
  image  = format("110110%5s%21s", rs.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    if rs.i == 0 then
      undefined; // rs =/= 00000
    else
      if rs == 0 then
        COMPACT_BRANCH = 1;
        NEXTPC = CIA + 4 + (sign_extend(DWORD, offset) << 2);
      endif;
    endif;
  }

op bnezc (rs: R, offset: card(21))
  init = {}
  syntax = format("bnezc %s, %<label>d", rs.syntax, offset)
  image  = format("111110%5s%21s", rs.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    if rs.i == 0 then
      undefined; // rs =/= 00000
    else
      if rs != 0 then
        COMPACT_BRANCH = 1;
        NEXTPC = CIA + 4 + (sign_extend(DWORD, offset) << 2);
      endif;
    endif;
  }

@rev(MIPS32_R6)
op Mips32BpuOpBXCRI = @rev(MIPS32_R6) blezc
                    | @rev(MIPS32_R6) bgezc
                    | @rev(MIPS32_R6) bgtzc
                    | @rev(MIPS32_R6) bltzc
                    | @rev(MIPS32_R6) beqzc
                    | @rev(MIPS32_R6) bnezc

@rev(MIPS32_R6)
op Mips32BpuOpBXCRRI = @rev(MIPS32_R6) bgec
                     | @rev(MIPS32_R6) blec
                     | @rev(MIPS32_R6) bltc
                     | @rev(MIPS32_R6) bgtc
                     | @rev(MIPS32_R6) bgeuc
                     | @rev(MIPS32_R6) bleuc
                     | @rev(MIPS32_R6) bltuc
                     | @rev(MIPS32_R6) bgtuc
                     | @rev(MIPS32_R6) beqc
                     | @rev(MIPS32_R6) bnec

/*
  BGEZL: Branch on Greater Than or Equal to Zero Likely (MIPS32, removed in Release 6)

  Encoding: | 31 26   | 25 21 | 20 16 | 15   0 |
            | REGIMM  | rs    | BGEZL | offset |
            | 000001  |       | 00011 |        |
            | 6       | 5     | 5     | 16     |

  Format: BGEZL rs, offset

  Description: if GPR[rs] >= 0 then branch_likely
  An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of
  the instruction following the branch (not the branch itself), in the branch delay slot, to form
  a PC-relative effective target address. If the contents of GPR rs are greater than or equal to
  zero (sign bit is 0), branch to the effective target address after the instruction in the delay
  slot is executed. If the branch is not taken, the instruction in the delay slot is not executed.

  Operation:
    I:
    target_offset <- sign_extend(offset || 02)
    condition <- GPR[rs] >= 0GPRLEN
    I+1:
    if condition then
      PC <- PC + target_offset
    else
      NullifyCurrentInstruction()
    endif
  */
@rev(MIPS32_REM_R6)
op bgezl (rs: R, offset: SHORT)
  init = {}
  syntax = format("bgezl %s, %<label>d", rs.syntax, offset)
  image  = format("000001%5s00011%16s", rs.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    if cast(LONG, rs) >= 0 then
      BRANCH = 1;
      NEXTPC = CIA + (sign_extend(DWORD, offset) << 2);
    else
      SKIPOP = 1;
    endif;
  }

/*
  BGTZ: Branch on Greater Than Zero (MIPS32)

  Encoding: | 31 26  | 25 21 | 20 16 | 15   0 |
            | BGTZ   | rs    | 0     | offset |
            | 000111 |       | 00000 |        |
            | 6      | 5     | 5     | 16     |

  Format: BGTZ rs, offset

  Description: if GPR[rs] > 0 then branch
  An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of
  the instruction following the branch (not the branch itself), in the branch delay slot, to form a
  PC-relative effective target address. If the contents of GPR rs are greater than zero (sign bit is
  0 but value not zero), branch to the effective target address after the instruction in the delay
  slot is executed.

  Operation:
    I:
    target_offset <- sign_extend(offset || 02)
    condition <- GPR[rs] > 0GPRLEN
    I+1:
    if condition then
      PC <- PC + target_offset
    endif
  */
@rev(MIPS32_R1)
op bgtz (rs: R, offset: SHORT)
  init = {}
  syntax = format("bgtz %s, %<label>d", rs.syntax, offset)
  image  = format("000111%5s00000%16s", rs.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    if cast(LONG, rs) > 0 then
      BRANCH = 1;
      NEXTPC = CIA + (sign_extend(DWORD, offset) << 2);
    endif;
  }

/*
  BGTZL: Branch on Greater Than Zero Likely (MIPS32, removed in Release 6)

  Encoding: | 31 26  | 25 21 | 20 16 | 15   0 |
            | BGTZL  | rs    | 0     | offset |
            | 010111 |       | 00000 |        |
            | 6      | 5     | 5     | 16     |

  Format: BGTZL rs, offset

  Description: if GPR[rs] > 0 then branch_likely
  An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of
  the instruction following the branch (not the branch itself), in the branch delay slot, to form a
  PC-relative effective target address.
  If the contents of GPR rs are greater than zero (sign bit is 0 but value not zero), branch to the
  effective target address after the instruction in the delay slot is executed. If the branch is not
  taken, the instruction in the delay slot is not executed.

  Operation:
    I:
    target_offset <- sign_extend(offset || 02)
    condition <- GPR[rs] > 0GPRLEN
    I+1:
    if condition then
      PC <- PC + target_offset
    else
      NullifyCurrentInstruction()
    endif
  */
@rev(MIPS32_REM_R6)
op bgtzl (rs: R, offset: SHORT)
  init = {}
  syntax = format("bgtzl %s, %<label>d", rs.syntax, offset)
  image  = format("010111%5s00000%16s", rs.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    if cast(LONG, rs) > 0 then
      BRANCH = 1;
      NEXTPC = CIA + (sign_extend(DWORD, offset) << 2);
    else
      SKIPOP = 1;
    endif;
  }

/*
  BLEZ: Branch on Less Than or Equal to Zero (MIPS32)

  Encoding: | 31 26  | 25 21 | 20 16 | 15   0 |
            | BLEZ   | rs    | 0     | offset |
            | 000110 |       | 00000 |        |
            | 6      | 5     | 5     | 16     |

  Format: BLEZ rs, offset

  Description: if GPR[rs] <= 0 then branch
  An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of
  the instruction following the branch (not the branch itself), in the branch delay slot, to form
  a PC-relative effective target address.
  If the contents of GPR rs are less than or equal to zero (sign bit is 1 or value is zero), branch
  to the effective target address after the instruction in the delay slot is executed.

  Operation:
    I:
    target_offset <- sign_extend(offset || 02)
    condition <- GPR[rs] <= 0GPRLEN
    I+1:
    if condition then
      PC <- PC + target_offset
    endif
  */
@rev(MIPS32_R1)
op blez (rs: R, offset: SHORT)
  init = {}
  syntax = format("blez %s, %<label>d", rs.syntax, offset)
  image  = format("000110%5s00000%16s", rs.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    if cast(LONG, rs) <= 0 then
      BRANCH = 1;
      NEXTPC = CIA + (sign_extend(DWORD, offset) << 2);
    endif;
  }

/*
  BLEZL: Branch on Less Than or Equal to Zero Likely (MIPS32, removed in Release 6)

  Encoding: | 31 26  | 25 21 | 20 16 | 15   0 |
            | BLEZL  | rs    | 0     | offset |
            | 010110 |       | 00000 |        |
            | 6      | 5     | 5     | 16     |

  Format: BLEZL rs, offset

  Description: if GPR[rs] <= 0 then branch_likely
  An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of
  the instruction following the branch (not the branch itself), in the branch delay slot, to form
  a PC-relative effective target address.
  If the contents of GPR rs are less than or equal to zero (sign bit is 1 or value is zero), branch
  to the effective target address after the instruction in the delay slot is executed. If the branch
  is not taken, the instruction in the delay slot is not executed.

  Operation:
    I:
    target_offset <- sign_extend(offset || 02)
    condition <- GPR[rs] <= 0GPRLEN
    I+1:
    if condition then
      PC <- PC + target_offset
    else
      NullifyCurrentInstruction()
    endif
  */
@rev(MIPS32_REM_R6)
op blezl (rs: R, offset: SHORT)
  init = {}
  syntax = format("blezl %s, %<label>d", rs.syntax, offset)
  image  = format("010110%5s00000%16s", rs.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    if cast(LONG, rs) <= 0 then
      BRANCH = 1;
      NEXTPC = CIA + (sign_extend(DWORD, offset) << 2);
    else
      SKIPOP = 1;
    endif;
  }

/*
  BLTZ: Branch on Less Than Zero (MIPS32)

  Encoding: | 31 26   | 25 21 | 20 16 | 15   0 |
            | REGIMM  | rs    | BLTZ  | offset |
            | 000001  |       | 00000 |        |
            | 6       | 5     | 5     | 16     |

  Format: BLTZ rs, offset

  Description: if GPR[rs] < 0 then branch
  An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of
  the instruction following the branch (not the branch itself), in the branch delay slot, to form
  a PC-relative effective target address. 
  If the contents of GPR rs are less than zero (sign bit is 1), branch to the effective target
  address after the instruction in the delay slot is executed.

  Operation:
    I:
    target_offset <- sign_extend(offset || 02)
    condition <- GPR[rs] < 0GPRLEN
    I+1:
    if condition then
      PC <- PC + target_offset
    endif
  */
@rev(MIPS32_R1)
op bltz (rs: R, offset: SHORT)
  init = {}
  syntax = format("bltz %s, %<label>d", rs.syntax, offset)
  image  = format("000001%5s00000%16s", rs.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    if cast(LONG, rs) < 0 then
      BRANCH = 1;
      NEXTPC = CIA + (sign_extend(DWORD, offset) << 2);
    endif;
  }

/*
  BLTZAL: Branch on Less Than Zero and Link (MIPS32, removed in Release 6)

  Encoding: | 31 26   | 25 21 | 20  16 | 15   0 |
            | REGIMM  | rs    | BLTZAL | offset |
            | 000001  |       | 10000  |        |
            | 6       | 5     | 5      | 16     |

  Format: BLTZAL rs, offset

  Description: if GPR[rs] < 0 then procedure_call
  Place the return address link in GPR 31. The return link is the address of the second instruction
  following the branch, where execution continues after a procedure call.
  An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of
  the instruction following the branch (not the branch itself), in the branch delay slot, to form
  a PC-relative effective target address.
  If the contents of GPR rs are less than zero (sign bit is 1), branch to the effective target
  address after the instruction in the delay slot is executed.

  Operation:
    I:
    target_offset <- sign_extend(offset || 02)
    condition <- GPR[rs] < 0GPRLEN
    GPR[31] <- PC + 8
    I+1:
    if condition then
      PC <- PC + target_offset
    endif
  */
@rev(MIPS32_REM_R6)
op bltzal (rs: R, offset: SHORT)
  init = {}
  syntax = format("bltzal %s, %<label>d", rs.syntax, offset)
  image  = format("000001%5s10000%16s", rs.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    GPR[31] = CIA + 8;

    if cast(LONG, rs) < 0 then
      BRANCH = 1;
      NEXTPC = CIA + (sign_extend(DWORD, offset) << 2);
    endif;
  }

/*
  BLTZALL: Branch on Less Than Zero and Link Likely (MIPS32, removed in Release 6)

  Encoding: | 31 26   | 25 21 | 20   16 | 15   0 |
            | REGIMM  | rs    | BLTZALL | offset |
            | 000001  |       | 10010   |        |
            | 6       | 5     | 5       | 16     |

  Format: BLTZALL rs, offset

  Description: if GPR[rs] < 0 then procedure_call_likely
  Place the return address link in GPR 31. The return link is the address of the second instruction
  following the branch, where execution continues after a procedure call.
  An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of
  the instruction following the branch (not the branch itself), in the branch delay slot, to form
  a PC-relative effective target address.
  If the contents of GPR rs are less than zero (sign bit is 1), branch to the effective target
  address after the instruction in the delay slot is executed. If the branch is not taken, the
  instruction in the delay slot is not executed.

  Operation:
    I:
    target_offset <- sign_extend(offset || 02)
    condition <- GPR[rs] < 0GPRLEN
    GPR[31] <- PC + 8
    I+1:
    if condition then
      PC <- PC + target_offset
    else
      NullifyCurrentInstruction()
    endif
  */
@rev(MIPS32_REM_R6)
op bltzall (rs: R, offset: SHORT)
  init = {}
  syntax = format("bltzall %s, %<label>d", rs.syntax, offset)
  image  = format("000001%5s10010%16s", rs.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    GPR[31] = CIA + 8;

    if cast(LONG, rs) < 0 then
      BRANCH = 1;
      NEXTPC = CIA + (sign_extend(DWORD, offset) << 2);
    else
      SKIPOP = 1;
    endif;
  }

/*
  BLTZL: Branch on Less Than Zero Likely (MIPS32, removed in Release 6)

  Encoding: | 31 26   | 25 21 | 20 16 | 15   0 |
            | REGIMM  | rs    | BLTZL | offset |
            | 000001  |       | 00010 |        |
            | 6       | 5     | 5     | 16     |

  Format: BLTZL rs, offset

  Description: if GPR[rs] < 0 then branch_likely
  An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of
  the instruction following the branch (not the branch itself), in the branch delay slot, to form
  a PC-relative effective target address.
  If the contents of GPR rs are less than zero (sign bit is 1), branch to the effective target
  address after the instruction in the delay slot is executed. If the branch is not taken, the
  instruction in the delay slot is not executed.

  Operation:
    I:
    target_offset <- sign_extend(offset || 02)
    condition <- GPR[rs] < 0GPRLEN
    I+1:
    if condition then
      PC <- PC + target_offset
    else
      NullifyCurrentInstruction()
    endif
  */
@rev(MIPS32_REM_R6)
op bltzl (rs: R, offset: SHORT)
  init = {}
  syntax = format("bltzl %s, %<label>d", rs.syntax, offset)
  image  = format("000001%5s00010%16s", rs.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    if cast(LONG, rs) < 0 then
      BRANCH = 1;
      NEXTPC = CIA + (sign_extend(DWORD, offset) << 2);
    else
      SKIPOP = 1;
    endif;
  }

/*
  BNE: Branch on Not Equal (MIPS32)

  Encoding: | 31 26   | 25 21 | 20 16 | 15   0 |
            | BNE     | rs    | rt    | offset |
            | 000101  |       |       |        |
            | 6       | 5     | 5     | 16     |

  Format: BNE rs, rt, offset

  Description: if GPR[rs] =/= GPR[rt] then branch
  An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of
  the instruction following the branch (not the branch itself), in the branch delay slot, to form
  a PC-relative effective target address.
  If the contents of GPR rs and GPR rt are not equal, branch to the effective target address after
  the instruction in the delay slot is executed.

  Operation:
    I:
    target_offset <- sign_extend(offset || 02)
    condition <- (GPR[rs] =/= GPR[rt])
    I+1:
    if condition then
      PC <- PC + target_offset
    endif
  */
@rev(MIPS32_R1)
op bne (rs: R, rt: R, offset: SHORT)
  init = {}
  syntax = format("bne %s, %s, %<label>d", rs.syntax, rt.syntax, offset)
  image  = format("000101%5s%5s%16s", rs.image, rt.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    if rs != rt then
      BRANCH = 1;
      NEXTPC = CIA + (sign_extend(DWORD, offset) << 2);
    endif;
  }

/*
  BNEL: Branch on Not Equal Likely (MIPS32, removed in Release 6)

  Encoding: | 31 26   | 25 21 | 20 16 | 15   0 |
            | BNEL    | rs    | rt    | offset |
            | 010101  |       |       |        |
            | 6       | 5     | 5     | 16     |

  Format: BNEL rs, rt, offset

  Description: if GPR[rs] =/= GPR[rt] then branch_likely
  An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of
  the instruction following the branch (not the branch itself), in the branch delay slot, to form
  a PC-relative effective target address.
  If the contents of GPR rs and GPR rt are not equal, branch to the effective target address after
  the instruction in the delay slot is executed. If the branch is not taken, the instruction in the
  delay slot is not executed.

  Operation:
    I:
    target_offset <- sign_extend(offset || 02)
    condition <- (GPR[rs] =/= GPR[rt])
    I+1:
    if condition then
      PC <- PC + target_offset
    else
      NullifyCurrentInstruction()
    endif
  */
@rev(MIPS32_REM_R6)
op bnel (rs: R, rt: R, offset: SHORT)
  init = {}
  syntax = format("bnel %s, %s, %<label>d", rs.syntax, rt.syntax, offset)
  image  = format("010101%5s%5s%16s", rs.image, rt.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    if rs != rt then
      BRANCH = 1;
      NEXTPC = CIA + (sign_extend(DWORD, offset) << 2);
    else
      SKIPOP = 1;
    endif;
  }

/*
  Return: Sum Overflow + Input Overflow
  output: temp_bit
*/
op sum_input_overflow(temp_a: DWORD, temp_b: DWORD)
  init = {}
  action = {
    temp_bit = 0;
    if sign_extend(WORD, temp_a<31>) != temp_a<63..32> ||
       sign_extend(WORD, temp_b<31>) != temp_b<63..32> then
      temp_bit = 1;
    endif;

    temp33 = temp_a<31>::temp_a<31..0> + temp_b<31>::temp_b<31..0>;
    if temp33<32> != temp33<31> then
      temp_bit = 1;
    endif;
  }

/*
  BOVC: Branch on Overflow, Compact; (MIPS32 Release 6)
  BNVC: Branch on No Overflow, Compact (MIPS32 Release 6)

  Encoding: | 31 26   | 25 21 | 20 16 | 15   0 |
            | POP10   | BOVC rs >= rt | offset |
            | 001000  | rs    | rt    |        |
            | POP30   | BNVC rs >= rt | offset |
            | 011000  | rs    | rt    |        |
            | 6       | 5     | 5     | 16     |

  Format:
    BOVC rs,rt,offset
    BNVC rs,rt,offset

  Description: branch if/if-not NotWordValue(GPR[rs]+GPR[rt])
    • BOVC performs a signed 32-bit addition of rs and rt. BOVC discards the sum, but detects signed
  32-bit integer overflow of the sum (and the inputs, in MIPS64), and branches if such overflow is
  detected.
    • BNVC performs a signed 32-bit addition of rs and rt. BNVC discards the sum, but detects signed
  32-bit integer overflow of the sum (and the inputs, in MIPS64), and branches if such overflow is
  not detected.

  BOVC and BNVC are compact branches—they have no branch delay slots, but do have a forbidden slot.
  A 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of
  the instruction following the branch (not the branch itself), to form a PC-relative effective
  target address.
  On 64-bit processors, BOVC and BNVC detect signed 32-bit overflow on the input registers as well
  as the output. This checking is performed even if 64-bit operations are not enabled.
  The special case with rt=0 (for example, GPR[0]) is allowed. On MIPS64, this checks that the input
  value of rs is a well-formed signed 32-bit integer: BOVC rs,r0,offset branches if rs is not a
  32-bit integer, and BNVC rs, r0 offset branches if rs is a 32-bit integer. On MIPS32,
  BOVC rs,r0 offset never branches, while BNVC rs,r0 offset always branches.
  The special case of rs=0 and rt=0 is allowed. BOVC never branches, while BNVC always branches.

  Operation:
    input_overflow <- NotWordValue(GPR[rs]) or NotWordValue(GPR[rt])
    temp1 <= sign_extend.32( GPR[rs]31..0 )
    temp2 <- sign_extend.32( GPR[rt]31..0 )
    tempd <- temp1 + temp2 // wider than 32-bit precision
    sum_overflow <- (tempd32 =/= tempd31)
    BOVC: cond <- sum_overflow or input_overflow
    BNVC: cond <- not( sum_overflow or input_overflow )
    if cond then
      PC <- ( PC+4 + sign_extend( offset << 2 ) )
   endif
  */
@rev(MIPS32_R6)
op bovc (rs: R, rt: R, offset: SHORT)
  init = {}
  syntax = format("bovc %s, %s, %<label>d", rs.syntax, rt.syntax, offset)
  image  = format("001000%5s%5s%16s", rs.image, rt.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    sum_input_overflow(rs<63..0>, rt<63..0>).action; // output: temp_bit

    if temp_bit == 1 then
      COMPACT_BRANCH = 1;
      NEXTPC = CIA + 4 + (sign_extend(DWORD, offset) << 2);
    endif;
  }

@rev(MIPS32_R6)
op bnvc (rs: R, rt: R, offset: SHORT)
  init = {}
  syntax = format("bnvc %s, %s, %<label>d", rs.syntax, rt.syntax, offset)
  image  = format("011000%5s%5s%16s", rs.image, rt.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;

    sum_input_overflow(rs<63..0>, rt<63..0>).action; // output: temp_bit

    if temp_bit != 1 then
      COMPACT_BRANCH = 1;
      NEXTPC = CIA + 4 + (sign_extend(DWORD, offset) << 2);
    endif;
  }

var temp28 [card(28)]

/*
  J: Jump (MIPS32)

  Encoding: | 31 26  | 25        0 |
            | J      | instr_index |
            | 000010 |             |
            | 6      | 26          |

  Format: J target

  Description:
  This is a PC-region branch (not PC-relative); the effective target address is in the “current” 256
  MB-aligned region. The low 28 bits of the target address is the instr_index field shifted left
  2bits. The remaining upper bits are the corresponding bits of the address of the instruction in
  the delay slot (not the branch itself).
  Jump to the effective target address. Execute the instruction that follows the jump, in the branch
  delay slot, before executing the jump itself.

  Operation:
    I:
    I+1:
    PC <- PCGPRLEN-1..28 || instr_index || 02
  */
@rev(MIPS32_R1)
op j (instr_index: card(26))
  init = {}
  syntax = format("j %<label>d", instr_index)
  image  = format("000010%26s", instr_index)
  action = {
    BRANCH_INSTRUCTION = 1;

    temp28 = coerce(card(28), instr_index) << 2;

    BRANCH = 1;
    NEXTPC = CIA<63..28>::temp28;
  }

/*
  JAL: Jump and Link (MIPS32)

  Encoding: | 31 26  | 25        0 |
            | JAL    | instr_index |
            | 000011 |             |
            | 6      | 26          |

  Format: JAL target MIPS32

  Description:
  Place the return address link in GPR 31. The return link is the address of the second instruction
  following the branch, at which location execution continues after a procedure call.
  This is a PC-region branch (not PC-relative); the effective target address is in the “current”
  256MB-aligned region. The low 28 bits of the target address is the instr_index field shifted left
  2bits. The remaining upper bits are the corresponding bits of the address of the instruction in
  the delay slot (not the branch itself).
  Jump to the effective target address. Execute the instruction that follows the jump, in the branch
  delay slot, before executing the jump itself.

  Operation:
    I:
    GPR[31] <- PC + 8
    I+1:
    PC <- PCGPRLEN-1..28 || instr_index || 02
  */
@rev(MIPS32_R1)
op jal (instr_index: card(26))
  init = {}
  syntax = format("jal %<label>d", instr_index)
  image  = format("000011%26s", instr_index)
  action = {
    BRANCH_INSTRUCTION = 1;

    temp28 = coerce(card(28), instr_index) << 2;

    GPR[31] = CIA + 8;

    BRANCH = 1;
    NEXTPC = CIA<63..28>::temp28;
  }

/*
  JALR: Jump and Link Register (MIPS32)

  Encoding: | 31 26   | 25 21 | 20 16 | 15 11      | 10  6 | 5    0 |
            | SPECIAL | rs    | 0     | rd         | hint  | JALR   |
            | 000000  |       | 00000 |            |       | 001001 |
            | SPECIAL | rs    | 0     | rd         | hint  | JALR   |
            | 000000  |       | 00000 | rd=/=00000 |       | 001001 |
            | 6       | 5     | 5     | 5          | 5     | 6      |

  Format:
    JALR rs (rd = 31 implied)
    JALR rd, rs

  Description: GPR[rd] <= return_addr, PC <- GPR[rs]
  Place the return address link in GPR rd. The return link is the address of the second instruction
  following the branch, where execution continues after a procedure call.
  For processors that do not implement the MIPS16e or microMIPS ISA:
    • Jump to the effective target address in GPR rs. If the target address is not 4-byte aligned,
    an Address Error exception will occur when the target address is fetched.
  For processors that do implement the MIPS16e or microMIPS ISA:
    • Jump to the effective target address in GPR rs. Set the ISA Mode bit to the value in GPR rs
    bit 0. Set bit 0 of the target address to zero. If the target ISA Mode bit is 0 and the target
    address is not 4-byte aligned, an Address Error exception will occur when the target instruction
    is fetched.
  In both cases, execute the instruction that follows the jump, in the branch delay slot, before
  executing the jump itself. In Release 1 of the architecture, the only defined hint field value is
  0, which sets default handling of JALR. In Release 2 of the architecture, bit 10 of the hint field
  is used to encode a hazard barrier. See the JALR.HB instruction description for additional
  information.

  Operation:
    I:
    temp <- GPR[rs]
    GPR[rd] <- PC + 8
    I+1:
    if Config3ISA = 1 then
      PC <- temp
    else
      PC <- tempGPRLEN-1..1 || 0
      ISAMode <= temp0
    endif
  */
@rev(MIPS32_R1)
op jalr2 (rd: R, rs: R)
  init = {
    hint = HINT_LOAD;
  }
  syntax = format("jalr %s, %s", rd.syntax, rs.syntax)
  image  = format("000000%5s00000%5s%5s001001", rs.image, rd.image, hint)
  action = {
    BRANCH_INSTRUCTION = 1;

    rd = CIA + 8;
    BRANCH = 1;
    
    if C0_CONFIG3_ISA == coerce(BIT, 0b0) then // TODO if Config3ISA = 1 then
      NEXTPC = rs;
    else
      temp_bit = coerce(BIT, 0b0);
      NEXTPC = rs<63..1>::temp_bit<0>;
      ISAMode = rs<0>;
    endif;
  }

@rev(MIPS32_R1)
op jalr (rs: R)
  init = {
    hint = HINT_LOAD;
  }
  syntax = format("jalr %s", rs.syntax)
  image  = format("000000%5s0000011111%5s001001", rs.image, hint)
  action = {
    jalr2(R(31), rs).action;
  }

/*
  JALR.HB Jump and Link Register with Hazard Barrier (MIPS32 Release 2)

  Encoding: | 31 26   | 25 21 | 20 16 | 15 11      | 10 | 9    6 | 5    0 |
            | SPECIAL | rs    | 0     | rd         |    | hint*  | JALR   |
            | 000000  |       | 00000 |            | 1  |        | 001001 |
            | SPECIAL | rs    | 0     | rd         |    | hint*  | JALR   |
            | 000000  |       | 00000 | rd=/=00000 | 1  |        | 001001 |
            | 6       | 5     | 5     | 5          | 1  | 4      | 6      |
  *Any other legal hint value

  Format:
    JALR.HB rs (rd = 31 implied)
    JALR.HB rd, rs

  Description: GPR[rd] <- return_addr, PC <- GPR[rs], clear execution and instruction hazards
  Place the return address link in GPR rd. The return link is the address of the second instruction
  following the branch, where execution continues after a procedure call.

  Operation:
    I:
    temp <- GPR[rs]
    GPR[rd] <- PC + 8
    I+1:
    if Config3ISA = 1 then
      PC <- temp
    else
      PC <- tempGPRLEN-1..1 || 0
      ISAMode <- temp0
    endif
    ClearHazards()
*/
@rev(MIPS32_R2)
op jalr_hb2 (rd: R, rs: R)
  init = {
    hint4b = HINT_LOAD;
  }
  syntax = format("jalr.hb %s, %s", rd.syntax, rs.syntax)
  image  = format("000000%5s00000%5s1%4s001001", rs.image, rd.image, hint4b)
  action = {
    jalr2(rd, rs).action;
    // TODO: ClearHazards()
  }

@rev(MIPS32_R2)
op jalr_hb (rs: R)
  init = {
    hint4b = HINT_LOAD;
  }
  syntax = format("jalr.hb %s", rs.syntax)
  image  = format("000000%5s00000111111%4s001001", rs.image, hint4b)
  action = {
    jalr_hb2(R(31), rs).action;
  }

/*
  JALX Jump and Link Exchange (MIPS32 with (microMIPS or MIPS16e), removed in Release 6)

  Encoding: | 31 26  | 25        0 |
            | JALX   | instr_index |
            | 011101 |             |
            | 6      | 26          |

  Format: JALX target

  Description:
  Place the return address link in GPR 31. The return link is the address of the second instruction
  following the branch, at which location execution continues after a procedure call. The value
  stored in GPR 31 bit 0 reflects the current value of the ISA Mode bit.
  This is a PC-region branch (not PC-relative); the effective target address is in the “current”
  256 MB-aligned region. The low 28 bits of the target address is the instr_index field shifted left
  2 bits. The remaining upper bits are the corresponding bits of the address of the instruction in
  the delay slot (not the branch itself). Jump to the effective target address, toggling the ISA
  Mode bit. Execute the instruction that follows the jump, in the branch delay slot, before
  executing the jump itself.

  Operation:
    I:
    GPR[31] <- PC + 8
    I+1:
    PC <- PCGPRLEN-1..28 || instr_index || 02
    ISAMode <- (not ISAMode)
  */
@rev(MIPS32_REM_R6)
op jalx (instr_index: card(26))
  init = {}
  syntax = format("jalx %<label>d", instr_index)
  image  = format("011101%26s", instr_index)
  action = {
    jal(instr_index).action;

    ISAMode = ~ISAMode;
  }

/*
  JIALC: Jump Indexed and Link, Compact (MIPS32 Release 6)

  Encoding: | 31 26  | 25 21 | 20 16 | 15   0 |
            | POP76  | JIALC | rt    | offset |
            | 111110 | 00000 |       |        |
            | 6      | 5     | 5     | 16     |

  Format: JIALC rt, offset

  Description: GPR[31] <- PC+4, PC <- ( GPR[rt] + sign_extend( offset ) )
  The jump target is formed by sign extending the offset field of the instruction and adding it to
  the contents of GPR rt. The offset is NOT shifted, that is, each bit of the offset is added to the
  corresponding bit of the GPR. Places the return address link in GPR 31. The return link is the
  address of the following instruction, where execution continues after a procedure call returns.
  Compact jumps do not have a delay slot. The instruction after the jump is NOT executed when the
  jump is executed.

  Operation:
    temp <- GPR[rt] + sign_extend(offset)
    GPR[31] <- PC + 4
    if Config3ISA = 1 then
      PC <- temp
    else
      PC <- (tempGPRLEN-1..1 || 0)
      ISAMode <- temp0
    endif
  */
// Release 6 instructions JIALC and BNEZC differ only in the rs field, instruction bits 21-25.
// JIALC and BNEZC occupy the same encoding as pre-Release 6 instruction encoding SDC2, which is recoded in Release 6.
@rev(MIPS32_R6)
op jialc (rt: R, offset: SHORT)
  init = {}
  syntax = format("jialc %s, %<label>d", rt.syntax, offset)
  image  = format("11111000000%5s%16s", rt.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;
    COMPACT_BRANCH = 1;
    BRANCH = 1;

    temp64 = rt + sign_extend(DWORD, offset);
    GPR[31] = CIA + 4;

    if C0_CONFIG3_ISA == coerce(BIT, 0b0) then // TODO if Config3ISA = 1 then
      NEXTPC = temp64;
    else
      temp_bit = coerce(BIT, 0b0);
      NEXTPC = temp64<63..1>::temp_bit<0>;
      ISAMode = temp64<0>;
    endif;
  }

/*
  JIC: Jump Indexed, Compact (MIPS32 Release 6)

  Encoding: | 31 26  | 25 21 | 20 16 | 15   0 |
            | POP66  | JIC   | rt    | offset |
            | 110110 | 00000 |       |        |
            | 6      | 5     | 5     | 16     |

  Format: JIC rt, offset

  Description: PC <- ( GPR[rt] + sign_extend( offset ) )
  The branch target is formed by sign extending the offset field of the instruction and adding it to
  the contents of GPR rt.
  The offset is NOT shifted, that is, each bit of the offset is added to the corresponding bit of
  the GPR.
  Compact jumps do not have a delay slot. The instruction after the jump is NOT executed when the
  jump is executed.

  Operation:
    temp <- GPR[rt] + sign_extend(offset)
    if Config3ISA = 1 then
      PC <- temp
    else
      PC <- (tempGPRLEN-1..1 || 0)
      ISAMode <- temp0
    endif
  */
// Release 6 instructions JIC and BEQZC differ only in the rs field. JIC and BEQZC occupy the same encoding as pre-
// Release 6 instruction LDC2, which is recoded in Release 6.
@rev(MIPS32_R6)
op jic (rt: R, offset: SHORT)
  init = {}
  syntax = format("jic %s, %<label>d", rt.syntax, offset)
  image  = format("11011000000%5s%16s", rt.image, offset)
  action = {
    BRANCH_INSTRUCTION = 1;
    COMPACT_BRANCH = 1;
    BRANCH = 1;

    temp64 = rt + sign_extend(DWORD, offset);

    if C0_CONFIG3_ISA == coerce(BIT, 0b0) then // TODO if Config3ISA = 1 then
      NEXTPC = temp64;
    else
      temp_bit = coerce(BIT, 0b0);
      NEXTPC = temp64<63..1>::temp_bit<0>;
      ISAMode = temp64<0>;
    endif;
  }

/*
  JR: Jump Register (MIPS32)

  Encoding: | 31 26   | 25 21 | 20 16 | 15 11 | 10  6 | 5    0 |
            | SPECIAL | rs    | 0     | 0     | hint  | JR     |
            | 000000  |       | 00000 | 00000 |       | 001000 |
            | 6       | 5     | 5     | 5     | 5     | 6      |

  Format: JR rs

  Description: PC <- GPR[rs]
  Jump to the effective target address in GPR rs. Execute the instruction following the jump, in the
  branch delay slot, before jumping.
  For processors that do not implement the MIPS16e or microMIPS ISA:
    • Jump to the effective target address in GPR rs. If the target address is not 4-byte aligned,
  an Address Error exception will occur when the target address is fetched.
  For processors that do implement the MIPS16e or microMIPS ISA:
    • Jump to the effective target address in GPR rs. Set the ISA Mode bit to the value in GPR rs
    bit 0. Set bit 0 of the target address to zero. If the target ISA Mode bit is 0 and the target
    address is not 4-byte aligned, an Address
  Error exception will occur when the target instruction is fetched.

  Operation:
    I:
    temp <- GPR[rs]
    I+1:
    if Config1CA = 0 then
      PC <- temp
    else
      PC <- tempGPRLEN-1..1 || 0
      ISAMode <- temp0
    endif
  */
@rev(MIPS32_R1)
op jr (rs: R)
  init = {
    hint = HINT_LOAD;
  }
  syntax = format("jr %s", rs.syntax)
  @rev(MIPS32_REM_R6) image  = format("000000%5s0000000000%5s001000", rs.image, hint)
  @rev(MIPS32_R6) image  = format("000000%5s0000000000%5s001001", rs.image, hint)
  action = {
    BRANCH_INSTRUCTION = 1;

    BRANCH = 1;

    if C0_CONFIG1_CA == coerce(BIT, 0b0) then
      NEXTPC = rs;
    else
      temp_bit = coerce(BIT, 0b0);
      NEXTPC = rs<63..1>::temp_bit<0>;
      ISAMode = rs<0>;
    endif;
  }

/*
  JR.HB Jump Register with Hazard Barrier

  pre-Release 6:
  Encoding: | 31 26   | 25 21 | 20 16 | 15 11 | 10 | 9   6 | 5    0 |
            | SPECIAL | rs    | 0     | 0     |    | hint* | JR     |
            | 000000  |       | 00000 | 00000 |    |       | 001000 |
            | 6       | 5     | 5     | 5     | 1  | 4     | 6      |

  Release 6:
  Encoding: | 31 26   | 25 21 | 20 16 | 15 11 | 10 | 9   6 | 5    0 |
            | SPECIAL | rs    | 0     | 0     |    | hint* | JALR   |
            | 000000  |       | 00000 | 00000 |    |       | 001001 |
            | 6       | 5     | 5     | 5     | 1  | 4     | 6      |
  *Any other legal hint value

  Format: JR.HB rs

  Description: PC <- GPR[rs], clear execution and instruction hazards
  Jump to the effective target address in GPR rs. Execute the instruction following the jump, in the
  branch delay slot, before jumping.

  Operation:
    I:
    temp <- GPR[rs]
    I+1:
    if Config1CA = 0 then
      PC <- temp
    else
      PC <- tempGPRLEN-1..1 || 0
      ISAMode <- temp0
    endif
    ClearHazards()
  */
@rev(MIPS32_R1)
op jr_hb (rs: R)
  init = {
    hint4b = HINT_LOAD;
  }
  syntax = format("jr.hb %s", rs.syntax)
  @rev(MIPS32_REM_R6) image  = format("000000%5s00000000001%4s001000", rs.image, hint4b)
  @rev(MIPS32_R6) image  = format("000000%5s00000000001%4s001001", rs.image, hint4b)
  action = {
    jr(rs).action;
    // TODO: ClearHazards()
  }

@rev(MIPS32_R1)
op MIPSBpuI = b
            | @rev(MIPS32_R1) j
            | @rev(MIPS32_R1) jal
            | @rev(MIPS32_REM_R6) jalx

@rev(MIPS32_R1)
op MIPSBpuR = @rev(MIPS32_R1) jalr
            | @rev(MIPS32_R2) jalr_hb
            | @rev(MIPS32_R1) jr
            | @rev(MIPS32_R1) jr_hb

@rev(MIPS32_R1)
op MIPSBpuRR = @rev(MIPS32_R1) jalr2
             | @rev(MIPS32_R2) jalr_hb2

@rev(MIPS32_R1)
op MIPSBpuRI = @rev(MIPS32_R6) bal
             | @rev(MIPS32_R1) bgez
             | @rev(MIPS32_R1) bgezal
             | @rev(MIPS32_REM_R6) bgezall
             | @rev(MIPS32_REM_R6) bgezl
             | @rev(MIPS32_R1) bgtz
             | @rev(MIPS32_REM_R6) bgtzl
             | @rev(MIPS32_R1) blez
             | @rev(MIPS32_REM_R6) blezl
             | @rev(MIPS32_R1) bltz
             | @rev(MIPS32_REM_R6) bltzal
             | @rev(MIPS32_REM_R6) bltzall
             | @rev(MIPS32_REM_R6) bltzl
             | @rev(MIPS32_R6) jialc
             | @rev(MIPS32_R6) jic

@rev(MIPS32_R1)
op MIPSBpuRRI = @rev(MIPS32_R1) beq
              | @rev(MIPS32_REM_R6) beql
              | @rev(MIPS32_R1) bne
              | @rev(MIPS32_REM_R6) bnel

@rev(MIPS32_R6)
op MIPSBpuCompactI = @rev(MIPS32_R6) bc

@rev(MIPS32_R6)
op MIPSBpuCompactRI = @rev(MIPS32_R6) balc
                    | @rev(MIPS32_R6) bXzalc
                    | @rev(MIPS32_R6) Mips32BpuOpBXCRI

@rev(MIPS32_R6)
op MIPSBpuCompactRRI = @rev(MIPS32_R6) Mips32BpuOpBXCRRI
                     | @rev(MIPS32_R6) bovc
                     | @rev(MIPS32_R6) bnvc

@rev(MIPS32_R1)
op MipsFXUBranch = @rev(MIPS32_R1) MIPSBpuI
                 | @rev(MIPS32_R1) MIPSBpuR
                 | @rev(MIPS32_R1) MIPSBpuRR
                 | @rev(MIPS32_R1) MIPSBpuRI
                 | @rev(MIPS32_R1) MIPSBpuRRI
                 | @rev(MIPS32_R6) MIPSBpuCompactI
                 | @rev(MIPS32_R6) MIPSBpuCompactRI
                 | @rev(MIPS32_R6) MIPSBpuCompactRRI

//==================================================================================================
// FP Branch
//==================================================================================================

/*  Instructions:
    BC1EQZ
    BC1NEZ
    BC1F
    BC1FL
    BC1T
    BC1TL
    BC2EQZ
    BC2NEZ
    BC2F
    BC2FL
    BC2T
    BC2TL
    */

/*
  BC1EQZ,
  BC1NEZ: Branch if Coprocessor 1 (FPU) Register Bit 0 Equal/Not Equal to Zero (MIPS32 Release 6)

  Encoding: | 31 26   | 25  21 | 20 16 | 15   0 |
            | COP1    | BC1EQZ | ft    | offset |
            | 010001  | 01001  |       |        |
            | COP1    | BC1NEZ | ft    | offset |
            | 010001  | 01101  |       |        |
            | 6       | 5      | 5     | 16     |

  Format: 
    BC1EQZ ft, offset
    BC1NEZ ft, offset

  Description:
    BC1EQZ: if FPR[ft] & 1 = 0 then branch
    BC1NEZ: if FPR[ft] & 1 =/= 0 then branch
  The condition is evaluated on FPU register ft.
    • For BC1EQZ, the condition is true if and only if bit 0 of the FPU register ft is zero.
    • For BC1NEZ, the condition is true if and only if bit 0 of the FPU register ft is non-zero.
  If the condition is false, the branch is not taken, and execution continues with the next
  instruction. A 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the
  address of the instruction following the branch (not the branch itself), to form a PC-relative
  effective target address. Execute the instruction in the delay slot before the instruction at the
  target.

  Operation:
    tmp <- ValueFPR(ft, UNINTERPRETED_WORD)
    BC1EQZ: cond <- tmp & 1 = 0
    BC1NEZ: cond <- tmp & 1 =/= 0
    if cond then
      I: target_PC <- ( PC+4 + sign_extend( offset << 2 )
      I+1: PC <- target_PC
  */
/*
op bc1eqz (rs: R, offset: SHORT)
  syntax = format("bc1eqz %s, %<label>d", rs.syntax, offset)
  image  = format("110010%26s", offset)
  action = {
    // TODO
  }
*/

//op MipsFPUBranch

@rev(MIPS32_R1)
op MipsBpuOp = MipsFXUBranch
             //| MipsFPUBranch

//==================================================================================================
// The End
//==================================================================================================

#endif

